# 排序 Sort

## O(n²)的排序

1. 选择排序 垃圾！
2. 插入排序，**在几乎有序的情况下，插入比选择快很多，接近 O(n)**
3. 冒泡排序，类似插入排序，但有区别，一定要注意！
4. 希尔排序，增量序列，太复杂了。。。

**优化思路，以排序的不必再排**

## O(nlogn)排序

1. 归并排序, 空间复杂度大, 分治一刀切

- 有序性优化
- 优化：小数组使用插入排序进一步优化

2. 快速排序, **partition 优化分的过程**, 近乎有序时，最差为**O(n²)**,因为树的高度不一定,平衡度很差,在大量重复元素时也为**O(n²)**

- 优化：小数组使用插入排序进一步优化
- 优化：随机取中间值
- 双路快排与三路快排(极大减少大量重复的排序)

3. 逆序对问题————衡量有序程度，归并排序可解
4. 第 n 大元素问题————快排可解

## 堆(Heap)和优先队列(PriorityQueue)

从 N 个元素中选出前 M 个元素，排序？NlogN；优先队列？NlogM

多路归并排序

使用堆实现优先队列？**O(nlogn)**

### 大顶堆和小顶堆

数组存储二叉堆(因为是最大(完全)二叉树)

主要用于动态数据的维护，效率上仍然不如 归并和快排

思路：2n+1

1. 分为大顶堆/小顶堆
2. 堆顶元素与末尾元素互换
3. 重新调整满足堆定义(shiftDown/shiftUp)

优化思路：

1. **swap** 函数，减少中间的交换次数
2. **heapify** 考虑不是叶子节点的节点从后往前依次 **shiftDown**（叶子节点均为大顶堆）**O(n)**
3. **原地堆排序** 排序原地进行，不开辟额外空间，空间复杂度 O(1)，用数组存储二叉堆

### 索引堆

交换的是索引 index, 比较处理数据的是 data

优化：反向查找表优化 reverses[] 与 indexes[]

## 排序算法的比较及稳定性

**稳定排序**：排序后，原来靠前的元素仍然靠前，相等元素的相对位置没有改变

**插入**、**归并**排序是稳定的，与实现方法息息相关，**快排**、**堆排序**不稳定

---

# 树 Tree

## 二叉搜索树 BST

解决查找问题，基础为 二分查找法(find,ceil,floor 三种方法)

1. 查找，插入，删除均为 O(logn)，动态维护数据
2. **min**、**max**、**successor 后继**、**predecessor 前驱**、**floor 小于最接近值**、**ceil 大于最接近值**、**rank**、**select**、**remove** 很容易实现
3. 实现——查找表（字典 KV）
4. 深度优先遍历：前序、中序(从小到大的 key 排序)、后序

   广度优先遍历：层序(运用队列实现)

   时间复杂度 O(n)

5. 局限性：有序数组的搜索树退化为链表，时间性能极差

   解决方案：

   1. 随机放入第一个节点 root 进行树的生成
   2. **平衡二叉树(红黑树)**，左右节点高度不会相差大于 1

6. 变种：Treap、trie、etc

- AVL 树与红黑树

  红黑树是平衡树性能的折中，AVL 树为完全平衡的树，其因为增删节点而导致的复衡操作效率和性能开销更大，但是因为其极度平衡的性质，搜索的效率更高；而红黑树就是 AVL 树性能的折中，统计性能上更好

- B 树与 B+ 树

   用于大块数据的读写操作，普遍用于数据库和文件系统。

   在B+树中只有叶子节点保存着数据信息，非叶子节点只有索引信息，而所有叶子节点以链表相连，便于区间查找遍历，数据存放更加紧密，缓存命中率高

   B树每个节点都有数据信息，遍历的时候，在离根节点近的节点经常访问，且访问会很快

# 并查集 Union Find

解决连接问题：(路径问题？并查集无法解决)

1. 判断网络节点连接状态
2. 实现数学集合

实现：

1. union(p, q)和 find(p)
2. isConnected(p, q)

优化：接近 O(1)

1. 基于 size 的优化 union
2. 基于树层数 rank 的优化 union
3. 路径压缩 find

# 图论 Graph Theory

分类：有向图、**无向图**/有权图、无权图

连通性？简单图（无自环边、无平行边）

## 图的表示(有向/无向)

1. 邻接矩阵————存储空间大，稠密的图
2. 邻接表————存储空间小，稀疏的图
