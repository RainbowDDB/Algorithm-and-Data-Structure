## 排序 Sort

### O(n²)的排序

1. 选择排序 垃圾！

2. 插入排序，**在几乎有序的情况下，插入比选择快很多，接近 O(n)**

3. 冒泡排序，类似插入排序，但有区别，一定要注意！

4. 希尔排序，增量序列，太复杂了。。。

**优化思路，以排序的不必再排**

### O(nlogn)排序

1. 归并排序, 空间复杂度大, 分治一刀切

- 有序性优化
- 优化：小数组使用插入排序进一步优化

2. 快速排序, **partition 优化分的过程**, 近乎有序时，最差为**O(n²)**,因为树的高度不一定,平衡度很差,在大量重复元素时也为**O(n²)**

- 优化：小数组使用插入排序进一步优化
- 优化：随机取中间值
- 双路快排与三路快排(极大减少大量重复的排序)

3. 逆序对问题————衡量有序程度，归并排序可解
4. 第 n 大元素问题————快排可解

## 堆(Heap)和优先队列

从 N 个元素中选出前 M 个元素，排序？NlogN；优先队列？NlogM

使用堆实现优先队列？**O(nlogn)**

### 大顶堆和小顶堆

数组存储二叉堆(因为是最大二叉树)

主要用于动态数据的维护，效率上仍然不如 归并和快排

思路：2n+1

1. 分为大顶堆/小顶堆
2. 堆顶元素与末尾元素互换
3. 重新调整满足堆定义(shiftDown/shiftUp)

优化思路：

1. **swap** 函数，减少中间的交换次数
2. **heapify** 考虑不是叶子节点的节点从后往前依次 **shiftDown**（叶子节点均为大顶堆）**O(n)**
3. **原地堆排序** 排序原地进行，不开辟额外空间，空间复杂度 O(1)，用数组存储二叉堆

### 索引堆

交换的是索引 index, 比较处理数据的是 data
